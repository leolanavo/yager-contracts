type User {
  id: ID!
  cpf: String!
  email: String!
  name: String!
  rg: String!
  signature: String!
  party: ID!
  companies: [Company!]!
}

type Company {
  id: ID!
  name: String!
  cnpj: String!
  segments: [String!]!
  documents: [String!]!
  party: ID!
}

type AppliedPayment {
  _id: String!
  baseCharge: Float!
  chargeDate: String!
  paymentDate: String
}

type Clause {
  _id: ID!
  text: String!
  payment: Payment
  references: [ID]
}

type Contract {
  _id: ID!
  mainParty: ID!
  secondaryParty: ID!
  startDate: String!
  endDate: String!
  extensions: [Extension!]
  appliedClauses: [AppliedClause!]
  terminatedBy: String
}

type AppliedClause {
  date: String!
  delayTolerance: Int
  numberNotifications: Int
  rescissory: Boolean!
  clauseID: String!
  notifications: [Notification!]
}

type Notification {
  _id: String!
  date: String!
}

type Extension {
  _id: ID!
  date: String!
  newEndDate: String!
}

type Payment {
  _id: ID!
  baseCharge: Float!
  kind: String!
  paymentDeadline: Int
  increments: [Increment]
}

type Increment {
  _id: ID!
  period: Int
  relativeRate: Float
  absoluteRate: Float
}

input ClauseInput {
  delayTolerance: Int
  numberNotifications: Int
  rescissory: Boolean!
  text: String!
  payment: PaymentInput
}

input PaymentInput {
  baseCharge: Float!
  kind: String!
  paymentDeadline: Int!
  increments: [IncrementInput]
}

input IncrementInput {
  period: Int
  relativeRate: Float
  absoluteRate: Float
}

type Query {
  getPayment(id: ID!): User!
  getBestRatedCompaniesBySegment(name: String!, segment: String!): Company!
}

type Mutation {
  # User resolvers
  """
    Create an user by inserting it into postgres and neo4j, also create a party
    to identify the user in contracts.

    **Arguments:**
    1. @arg `cpf`: user's cpf, must be unique and a valid cpf
    2. @arg `email`: user's email, must be unique
    3. @arg `name`: user's name
    4. @arg `rg`: user's rg

    **Return:** The saved user and an User data type.
  """
  createUser(cpf: String!, email: String!, name: String!, rg: String!): User!
  addRepresentation(userId: ID!, companyId: ID!): User!

  # Company resolvers
  createCompany(name: String!, cnpj: String!, segments: [ID!]! , documents: [ID!]!): Company!
  add

  # Payment resolvers
  createPayment(baseCharge: Float!, chargeDate: String!, paymentDate: String): AppliedPayment!
  addPayment(clauseId: ID!, baseCharge: Float!, type: String!, paymentDeadline: Int): Payment!
  addIncrement(paymentId: ID!, period: Int, relativeRate: Float!, absoluteRate: Float!): Increment!

  # Contract resolvers
  """
    Create a contract into mongodb, postres and neo4j.

    **Arguments:**
    1. @arg `mainParty`: the main party's ID
    2. @arg `secondaryParty`: the secondary party's ID
    3. @arg `startDate`: the date which the contract starts to be valid
    4. @arg `endDate`: the date which the contract is no more valid
    4. @arg `clauses`: and array of the complex type clauseInput.

    **Return:** The saved contract and a Contract data type.
  """
  createContract(mainParty: ID!, secondaryParty: ID!, startDate: String!, endDate: String!, clauses: [ClauseInput!]!): Contract!
  """
    Add an extension to the validity of a contract, registering a new end date to the contract.

    **Arguments:**
    1. @arg `contractID`: the ID of the contract to be extended
    2. @arg `date`: the date this extension is applied
    3. @arg `newEndDate`: the date which the contract is still valid until

    **Return:** The updated contract and a Contract data type.
  """
  addExrension(contractID: ID!, date: String!, newEndDate: String!): Contract!
  createClause(text: String!): Clause!
}